Class {
	#name : #BrMenuItems,
	#superclass : #Object,
	#instVars : [
		'items',
		'parent',
		'selectedItem',
		'announcer'
	],
	#category : #'Brick-Menu - Model'
}

{ #category : #'add / remove' }
BrMenuItems >> addItem: aMenuItem [
	aMenuItem parent: self parent.
	self items add: aMenuItem.
	
	aMenuItem isSelected ifTrue: [
		self selectedItem: aMenuItem ].

	aMenuItem announcer
		when: BrMenuItemSelectionChanged
		send: #onMenuItemSelection:
		to: self
]

{ #category : #'add / remove' }
BrMenuItems >> addItemLabel: aText action: anAction [
	| aMenuItem |
	aMenuItem := BrMenuActionItem new.
	aMenuItem label: aText.
	aMenuItem action: anAction.
	self addItem: aMenuItem
]

{ #category : #'add / remove' }
BrMenuItems >> addItemLabel: aLabelString shortcut: aShortcutString action: anAction [
	| aMenuItem |
	aMenuItem := BrMenuActionItem new.
	aMenuItem label: aLabelString shortcut: aShortcutString.
	aMenuItem action: anAction.
	self addItem: aMenuItem
]

{ #category : #accessing }
BrMenuItems >> announcer [
	^ announcer
]

{ #category : #'api - converting' }
BrMenuItems >> asElement [
	| anElement |
	anElement := BrSimpleList new
			fitContentLimited;
			items: self items;
			stencil: [ :aRowValue :anIndex :aListWidget | aRowValue asElement ];
			geometry: (BlRoundedRectangleGeometry cornerRadius: 4);
			padding: (BlInsets all: 5);
			border: (BlBorder paint: Color veryLightGray width: 1).

	self announcer weak
		when: BrMenuItemsHideRequest
		send: #removeFromParent
		to: anElement.
	^ anElement
]

{ #category : #'api - selection' }
BrMenuItems >> deselect [
	selectedItem ifNotNil: #deselect.
	selectedItem := nil
]

{ #category : #'api - selection' }
BrMenuItems >> deselectedItem: aMenuItem [
	self assert: [ aMenuItem isSelected not ].
	selectedItem == aMenuItem ifFalse: [ ^ self ].

	selectedItem := nil
]

{ #category : #'api - grouping' }
BrMenuItems >> groups [
	<return: #Array of: #BrMenuItemGroup>
	| aDictionary |
	aDictionary := Dictionary new.
	self items
		do: [ :eachItem | 
			aDictionary
				at: eachItem group id
				ifPresent: [ :aGroup | aGroup addItem: eachItem ]
				ifAbsentPut: [ BrMenuItemGroup new addItem: eachItem ] ].

	^ aDictionary values sort: [ :a :b | a priority < b priority ]
]

{ #category : #'gt - extensions' }
BrMenuItems >> gtGroupsFor: aView [
	<gtView>
	^ aView columnedTree
		title: 'Grouped menu items';
		priority: 10;
		items: [ self groups ifNil: [ #() ] ];
		children: #gtItemChildren;
		expandAll;
		column: 'Label' text: [ :anItem | anItem gtItemLabel ];
		column: 'Selection'
			text: #gtItemSelection
			weight: 0.2;
		column: 'Depth'
			text: #gtItemDepth
			weight: 0.2;
		column: 'Type' text: #class weight: 0.5
]

{ #category : #'gt - extensions' }
BrMenuItems >> gtItemsFor: aView [
	<gtView>
	^ aView columnedTree
		title: 'Menu items';
		items: [ self items ifNil: [ #() ] ];
		children: #gtItemChildren;
		expandAll;
		column: 'Label' text: [ :anItem | anItem gtItemLabel ];
		column: 'Selection'
			text: [ :anItem | GtPhlowOverviewItem new 
				boolean: anItem isSelected; 
				description ]
			weight: 0.2;
		column: 'Depth'
			text: [ :anItem | 
				| aDepth |
				aDepth := 1.
				anItem parentsDo: [ aDepth := aDepth + 1 ].
				aDepth ]
			weight: 0.2;
		column: 'Type' text: #menuType weight: 0.5
]

{ #category : #'api - visibility' }
BrMenuItems >> hide [
	self deselect.
	announcer announce: (BrMenuItemsHideRequest new menuItems: self)
]

{ #category : #initialization }
BrMenuItems >> initialize [
	super initialize.
	announcer := Announcer new.
	items := OrderedCollection new
]

{ #category : #accessing }
BrMenuItems >> items [
	^ items
]

{ #category : #accessing }
BrMenuItems >> items: aCollection [
	aCollection parent: self parent.
	items := aCollection
]

{ #category : #accessing }
BrMenuItems >> itemsCount [
	^ self items size
]

{ #category : #accessing }
BrMenuItems >> menuType [
	^ self class
]

{ #category : #'event handling' }
BrMenuItems >> onMenuItemSelection: anAnnouncement [
	anAnnouncement menuItem isSelected
		ifTrue: [ self selectedItem: anAnnouncement menuItem ]
		ifFalse: [ self deselectedItem: anAnnouncement menuItem ]
]

{ #category : #accessing }
BrMenuItems >> parent [
	^ parent
]

{ #category : #accessing }
BrMenuItems >> parent: anObject [
	parent := anObject
]

{ #category : #printing }
BrMenuItems >> printOn: aStream [
	super printOn: aStream.

	aStream
		space;
		nextPut: $[;
		print: self itemsCount;
		space;
		nextPutAll: ('item' asPluralBasedOn: self itemsCount);
		nextPut: $]
]

{ #category : #accessing }
BrMenuItems >> selectedItem [
	^ selectedItem
]

{ #category : #'api - selection' }
BrMenuItems >> selectedItem: aMenuItem [
	self assert: [ aMenuItem isSelected ].
	selectedItem == aMenuItem ifTrue: [ ^ self ].

	selectedItem ifNotNil: #deselect.
	selectedItem := aMenuItem
]
